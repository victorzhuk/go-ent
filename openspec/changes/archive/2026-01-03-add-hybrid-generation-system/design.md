# Design: Hybrid Generation System

## Context

Go-ent aims to be an enterprise Go development toolkit combining:
- Spec-driven development (OpenSpec)
- MCP-based AI tooling
- Project scaffolding and code generation

The hybrid generation system bridges the gap between rigid template-based generation and inconsistent AI-only generation by combining the strengths of both approaches.

### Problem Statement

| Approach | Strength | Weakness |
|----------|----------|----------|
| Templates only | Consistent, fast, auditable | Rigid, no context awareness |
| AI prompts only | Flexible, context-aware | Inconsistent, may hallucinate |
| **Hybrid** | Both | Complexity |

### Constraints

- Must work as MCP server (no HTTP, no interactive prompts)
- Must integrate with existing OpenSpec workflow
- Must use embedded templates from `add-mcp-generation-tools`
- AI generation happens client-side (MCP server provides prompts, not executes AI)
- Must be backwards compatible with existing projects

### Stakeholders

- Developers scaffolding new Go projects
- AI assistants using MCP tools for generation
- Teams adopting spec-driven development

## Goals / Non-Goals

### Goals

- Define `generation.yaml` schema for project configuration
- Create spec analyzer that identifies components and patterns
- Implement component generation from spec + templates
- Provide AI prompt templates for business logic generation
- Mark extension points in generated code for AI to fill

### Non-Goals

- Executing AI generation server-side (client responsibility)
- Supporting non-Go languages
- Creating visual generation UI
- Real-time code generation (batch only)
- Replacing OpenSpec with new spec format

## Decisions

### Decision 1: Generation Configuration Location

**Choice**: Add `generation.yaml` to `openspec/` directory

```yaml
openspec/
├── generation.yaml     # Generation settings
├── project.md          # Conventions
└── specs/              # Capabilities
```

**Rationale**:
- Keeps all project configuration together
- Optional file - defaults work without it
- Follows OpenSpec's brownfield philosophy

**Alternatives Considered**:
- Separate `go-ent.yaml` at root: Fragments configuration
- Inline in `project.md`: Hard to parse, mixes concerns
- Per-spec generation: Too granular, complex

### Decision 2: generation.yaml Schema

**Choice**: Minimal schema with sensible defaults

```yaml
# openspec/generation.yaml
defaults:
  go_version: "1.25"
  archetype: standard

archetypes:
  # Override built-in or define custom
  my-archetype:
    templates:
      - go.mod
      - main
      - config
      - custom-thing
    skip:
      - dockerfile  # Exclude from generation

components:
  # Map specs to generated components
  - name: user-service
    spec: specs/user-management/spec.md
    archetype: api-service  # Override default
    output: internal/user/
```

**Built-in Archetypes**:

| Archetype | Description | Key Templates |
|-----------|-------------|---------------|
| `standard` | Web service with clean architecture | main, config, api, handler |
| `mcp` | MCP server plugin | main, mcp-server |
| `api` | API-only service (no web) | main, config, handler |
| `grpc` | gRPC service | main, grpc-server, proto |
| `worker` | Background worker | main, config, worker |

### Decision 3: Spec Analysis Strategy

**Choice**: Pattern-based heuristic analysis with explicit override

**How it works**:

1. Parse spec file for requirements and scenarios
2. Identify patterns from keywords and structure:
   - CRUD patterns: "create", "update", "delete", "retrieve"
   - API patterns: "endpoint", "request", "response"
   - Async patterns: "queue", "worker", "background"
   - Auth patterns: "authenticate", "authorize", "permission"
3. Score archetypes based on pattern matches
4. Allow explicit override in generation.yaml

```go
type SpecAnalysis struct {
    Patterns    []PatternMatch   // Detected patterns
    Components  []Component      // Identified components
    Archetype   string           // Recommended archetype
    Confidence  float64          // 0.0-1.0
}

type PatternMatch struct {
    Pattern     string   // e.g., "crud", "api", "async"
    Evidence    []string // Lines that matched
    Score       float64
}
```

**Rationale**:
- Heuristics are fast and deterministic
- Explicit override handles edge cases
- Confidence score helps user decide

### Decision 4: Extension Point Syntax

**Choice**: Comment-based markers in templates

```go
// Generated by go-ent. Modify extension points below.

package usecase

type UserUseCase struct {
    repo UserRepository
}

// @generate:constructor
// Extension point: Add dependencies and initialization

func NewUserUseCase(repo UserRepository) *UserUseCase {
    return &UserUseCase{repo: repo}
}

// @generate:methods
// Extension point: Generate use case methods from spec requirements
// Spec: specs/user-management/spec.md
// Requirements:
//   - CreateUser: The system SHALL allow creating new users
//   - GetUser: The system SHALL retrieve user by ID
```

**Marker Format**:
```
// @generate:<type>
// <context for AI>
```

**Types**:
- `constructor` - Dependency injection points
- `methods` - Business logic methods
- `validation` - Input validation logic
- `handlers` - HTTP/gRPC handlers
- `tests` - Test case generation

**Rationale**:
- Comments don't break Go syntax
- Easy to detect and extract
- Provides context for AI generation
- Can be left as documentation if not filled

### Decision 5: AI Prompt Template Format

**Choice**: Markdown templates with variable substitution

```markdown
# prompts/usecase.md

## Context
You are generating a use case implementation for a Go service.

## Spec
{{.SpecContent}}

## Requirements to Implement
{{range .Requirements}}
- {{.Name}}: {{.Description}}
{{end}}

## Generated Code So Far
```go
{{.ExistingCode}}
```

## Instructions
1. Implement each requirement as a method
2. Follow clean architecture patterns
3. Return proper errors with context
4. Add input validation

## Output Format
Generate only the method implementations. Do not regenerate the struct.
```

**Variables**:
- `{{.SpecContent}}` - Full spec file content
- `{{.Requirements}}` - Parsed requirements
- `{{.ExistingCode}}` - Already generated scaffold
- `{{.ProjectName}}` - Project identifier
- `{{.Conventions}}` - From project.md

### Decision 6: Generation Workflow

**Choice**: Two-stage generation (structure, then logic)

```
┌─────────────────────────────────────────────────────────────┐
│                 Stage 1: Structure Generation                │
│         (Deterministic - Templates + Variables)              │
├─────────────────────────────────────────────────────────────┤
│ 1. Read generation.yaml (or use defaults)                   │
│ 2. Analyze spec to identify components                      │
│ 3. Select archetype and templates                           │
│ 4. Generate scaffold with extension points                  │
│ 5. Return generated files + prompt templates                │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 Stage 2: Logic Generation                    │
│            (AI-Driven - Client Responsibility)               │
├─────────────────────────────────────────────────────────────┤
│ 1. MCP tool returns prompt templates with context           │
│ 2. Client (Claude Code) executes prompts                    │
│ 3. AI fills extension points with business logic            │
│ 4. Human reviews and approves generated code                │
└─────────────────────────────────────────────────────────────┘
```

**Rationale**:
- Keeps MCP server stateless and fast
- AI execution is client responsibility
- Clear separation of deterministic vs. non-deterministic
- Matches MCP's tool-based architecture

## Risks / Trade-offs

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Spec analysis misidentifies patterns | Medium | Low | Allow explicit override, show confidence |
| Extension points clutter code | Low | Medium | Clear syntax, can be stripped |
| AI generates incorrect code | Medium | Medium | Templates provide structure, human review |
| generation.yaml adds complexity | Low | Low | Fully optional, sensible defaults |
| Upstream OpenSpec changes conflict | Low | Medium | Keep extensions minimal, namespace if needed |

## Migration Plan

This change is additive and non-breaking:

1. **Phase 1**: Add generation.yaml support (optional file)
2. **Phase 2**: Add spec analyzer (pure read-only)
3. **Phase 3**: Add generation tools (new commands only)
4. **Phase 4**: Add prompt templates (new files only)

**Rollback**: Simply remove new files. No existing functionality affected.

## Open Questions

1. **Should prompts be embedded in binary?**
   - Tentative: No, keep in `prompts/` for easy customization
   - Revisit: May embed defaults with override

2. **Should analysis cache results?**
   - Tentative: No, specs are small and fast to parse
   - Revisit: Add caching if performance issues

3. **Should generation.yaml support inheritance?**
   - Tentative: No, keep simple
   - Revisit: May add `extends: base-config.yaml` later

## Component Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      MCP Server                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                tools/generate_component.go              │ │
│  │                tools/generate_from_spec.go              │ │
│  │                tools/archetypes.go                      │ │
│  └──────────────────────────┬─────────────────────────────┘ │
│                              │                               │
│  ┌──────────────────────────▼─────────────────────────────┐ │
│  │                  generation/                            │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │ │
│  │  │ config.go   │  │ analyzer.go │  │ archetypes.go   │ │ │
│  │  │ Parse YAML  │  │ Spec→Pattern│  │ Template lists  │ │ │
│  │  └──────┬──────┘  └──────┬──────┘  └────────┬────────┘ │ │
│  │         │                │                   │          │ │
│  │         └────────────────┼───────────────────┘          │ │
│  │                          ▼                              │ │
│  │  ┌─────────────────────────────────────────────────────┐│ │
│  │  │                     mapper.go                        ││ │
│  │  │        Spec Analysis + Config → Template List       ││ │
│  │  └─────────────────────────────────────────────────────┘│ │
│  │                          │                              │ │
│  │  ┌───────────────────────▼─────────────────────────────┐│ │
│  │  │                    prompts.go                        ││ │
│  │  │              Load and populate prompts              ││ │
│  │  └─────────────────────────────────────────────────────┘│ │
│  └────────────────────────────────────────────────────────┘ │
│                              │                               │
│                              ▼                               │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                templates/embed.go                       │ │
│  │              (from add-mcp-generation-tools)            │ │
│  └────────────────────────────────────────────────────────┘ │
│                              │                               │
└──────────────────────────────┼───────────────────────────────┘
                               │
                               ▼
              ┌────────────────────────────────┐
              │         Generated Files         │
              │  + Extension Point Markers      │
              │  + AI Prompt Templates          │
              └────────────────────────────────┘
```
